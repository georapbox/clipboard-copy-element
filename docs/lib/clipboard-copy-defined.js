Object.defineProperty({}, "ClipboardCopy", { get: function () { return i }, set: void 0, enumerable: !0, configurable: !0 }); let t = "clipboard-copy", e = "success", o = "error", s = document.createElement("template"); s.innerHTML = `
  <style>
    :host([hidden]),
    [hidden],
    ::slotted([hidden]) {
      display: none !important;
    }
  </style>

  <button type="button" part="button">
    <slot name="copy">Copy</slot>
    <slot name="success" hidden>Copied!</slot>
    <slot name="error" hidden>Error</slot>
  </button>
`; class i extends HTMLElement { #t = null; #e; #o; #s; #i; constructor() { super(), this.shadowRoot || (this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(s.content.cloneNode(!0))), this.#e = this.shadowRoot.querySelector("button"), this.#o = this.shadowRoot.querySelector('slot[name="copy"]'), this.#s = this.shadowRoot.querySelector('slot[name="success"]'), this.#i = this.shadowRoot.querySelector('slot[name="error"]') } static get observedAttributes() { return ["disabled"] } connectedCallback() { this.#r("value"), this.#r("from"), this.#r("disabled"), this.#e && this.#e.addEventListener("click", this.#n) } disconnectedCallback() { this.#e && this.#e.removeEventListener("click", this.#n) } attributeChangedCallback(t) { "disabled" === t && this.#e && (this.#e.disabled = this.disabled, this.#e.setAttribute("aria-disabled", this.disabled), this.#e.part && this.#e.part.contains("button") && this.#e.part.toggle("button--disabled", this.disabled)) } get disabled() { return this.hasAttribute("disabled") } set disabled(t) { t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled") } get feedbackDuration() { return Number(this.getAttribute("feedback-duration")) || 1e3 } set feedbackDuration(t) { this.setAttribute("feedback-duration", t) } get value() { return this.getAttribute("value") } set value(t) { this.setAttribute("value", t) } get from() { return this.getAttribute("from") } set from(t) { this.setAttribute("from", t) } async #l() { if (this.value || this.from) try { let o = ""; if (this.value) o = this.value; else if (this.from) { let t = "getRootNode" in Element.prototype ? this.#e.getRootNode({ composed: !0 }) : this.#e.ownerDocument, e = t.querySelector(this.from); if (!e) return; o = e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement ? e.value : e instanceof HTMLAnchorElement && e.hasAttribute("href") ? e.href : e.textContent } await navigator.clipboard.writeText(o), this.#a(e), this.dispatchEvent(new CustomEvent(`${t}-success`, { bubbles: !0, composed: !0, detail: { value: o } })) } catch (e) { this.#a(o), this.dispatchEvent(new CustomEvent(`${t}-error`, { bubbles: !0, composed: !0, detail: { error: e } })) } } #n = t => { t.preventDefault(), this.disabled || this.#t || this.#l() }; #a(t) { this.#o.hidden = !0, this.#s.hidden = t !== e, this.#i.hidden = t !== o, this.#e && (this.#e.part.remove("button--success"), this.#e.part.remove("button--error"), this.#e.part.add(`button--${t}`)), clearTimeout(this.#t), this.#t = setTimeout(() => { this.#o.hidden = !1, this.#s.hidden = !0, this.#i.hidden = !0, this.#e && this.#e.part.remove(`button--${t}`), this.#t = null }, this.feedbackDuration) } #r(t) { if (Object.prototype.hasOwnProperty.call(this, t)) { let e = this[t]; delete this[t], this[t] = e } } static defineCustomElement(e = t) { "undefined" == typeof window || window.customElements.get(e) || window.customElements.define(e, i) } } i.defineCustomElement(); export { i as ClipboardCopy };
